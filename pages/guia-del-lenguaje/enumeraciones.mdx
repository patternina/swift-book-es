---
title: Enumeraciones
---

import CodeSnippet from '../../components/CodeSnippet.js'
import Callout from '../../components/Callout.js'

# Enumeraciones

Una _enumeración_ define un tipo común para un grupo de valores realaciondos y le permite trabajar con esos valores de forma segura utilizando tipos de datos verificados.

Si está familiarizado con lenguaje C, sabrá que las enumeraciones de C asignan nombres relacionados a un conjunto de valores enteros. Las enumeraciones en Swift son mucho más flexibles y no tienen que proporcionar un valor para cada caso de la enumeración. Si se proporciona un valor (conocido como _raw o predeterminado_ ) para cada caso de enumeración, el valor puede ser una cadena, un carácter o un valor de cualquier tipo entero o de punto flotante.

Alternativamente, los casos de enumeración pueden especificar valores asociados de cualquier tipo que se almacenarán junto con cada valor de caso diferente, como lo hacen las uniones o variantes en otros idiomas. Usted puede definir un conjunto común de casos relacionados como parte de una enumeración, cada uno de los cuales tiene un conjunto diferente de valores de tipos apropiados asociados.

Las enumeraciones en Swift son tipos de primera clase en su propio derecho. Adoptan muchas características tradicionalmente soportadas solamente por clases, talas como propiedades calculadas para proporcionar información adicional acerca de el valor actual de la enumeración e instancias de métodos para proporcionar funcionalidad relacionada a los valores que representa la enumeración.  Las enumeraciones también pueden definir inicializadores para proporcionar un valor de caso inicial; se pueden extender para expandir su funcionalidad más allá de la implementación original; y pueden ajustarse a los protocolos para proporcionar una funcionalidad estándar. 

Para más información de estas características, vea [Propiedades](./propiedades), [Métodos](./metodos), [Inicialización](./inicializacion), [Extensiones](./extensiones), and [Protocolos](./protocolos).

## Enumeración: Sintáxis

Puede declarar enumeraciones con la palabra reservada `enum` y poner la definición completa entre un par de llaves:

<CodeSnippet>
  {`enum AlgunaEnumeration {
    // la definición de la enumeración va aquí
}`}
</CodeSnippet>

Aquí está un ejemplo para los cuatro puntos principales de una brújula:

<CodeSnippet>
  {`enum PuntoCardinal {
    case norte
    case sur
    case este
    case oeste
}`}
</CodeSnippet>

Los valores definidos en una enumeración (tales como `norte`, `sur`, `este`, y `oeste`) son sus _casos de enumeración_. Se usa la palabra reservada  `case` para definir un nuevo caso de la enumeración.

<Callout>
  En Swift los casos de enumeración no tienen un valor entero asignado por default, a diferencia
  de lenguajes como C y Objective-C. En el ejemplo anterior de  `PuntoCardinal`,
  `norte`, `sur`, `este`, y `oeste` no corresponden a los valores `0`, `1`, `2`, y
  `3`. Por el contrario, los diferentes casos de la enumeración tienen su propio valor,
  con un explicitamente definido en  `PuntoCardinal`.
</Callout>

Se pueden declarar múlltiples casos en una sola línea, separados por comas:

<CodeSnippet>
  {`enum Planeta {
    case mercurio, venus, tierra, marte, jupiter, saturno, urano, neptuno
}`}
</CodeSnippet>

Cada declaración de una enumeración define un nuevo tipo. Como los otros tipos en Swift, sus nombre (tales como `PuntoCardinal` and `Planeta`) inician con una letra mayúscula. Dé a los tipos de enumeración nombres singulares en lugar de plurales, para que se lean como evidentes:


<CodeSnippet>{`var avanzarEnDireccion = PuntoCardinal.norte`}</CodeSnippet>

El tipo de  `avanzarEnDireccion` se infiere cuando es inicializado con uno de los posibles valores de `PuntoCardinal`. Una vez que  `avanzarEnDireccion` es declarado como un  `PuntoCardinal`, se puede cambiar a un diferente valor de `PuntoCardinal` de forma corte usando un punto la sintaxis es:

<CodeSnippet>{`avanzarEnDireccion = .este`}</CodeSnippet>

El tipo de `avanzarEnDireccion` ya se conoce, por lo tanto se puede asiganar el otro tipo cuando se asigna su valor. Esto hace que el código sea muy legible cuando se trabaja con valores de enumeración escritos explícitamente.

 ## Utilización de los valores de una Enumeración en una sentencia switch

Se puede busca la coincidencia de los valores individuales de una enumeración con una sentencia`switch:

<CodeSnippet>
  {`avanzarEnDireccion = .sur\n
switch avanzarEnDireccion {
case .norte:
    print("Muchos planetas tienen un norte")
case .sur:
    print("Mira los pingüinos")
case .este:
    print("Donde nace el sol")
case .oeste:
    print("donde el cielo es azul")
}
// Prints "Mira los pingüinos"`}
</CodeSnippet>

El código se puede leer como:

“Considerando del valor de `avanzarEnDireccion`. En caso de que sea `.norte`, imprime `"Muchos planetas tienen un norte"`. En caso de que sea igula a `.sur`, imprime `"Mira los pingüinos"`.”

…y así sucesivamente.

Como se describe en [Flujos de Control](./flujo-de-control), una sentencia `switch`  debe ser exhaustiva al considerar los casos de una enumeración. Si se omite el caso para `.oeste`,  este código no compila, porque no considera la lista completa de casos de PuntoCardinal. Requerir exhaustividad garantiza que los casos de enumeración no se omitan accidentalmente.

Cuando no sea apropiado proporcionar un `case` para cada caso de la enumeración, se puede proporcionar un caso `default` para cubrir cualquier caso que no se use explícitamente:

<CodeSnippet>
  {`let algunPlaneta = Planeta.tierra\n
switch algunPlaneta {
case .tierra:
    print("Mayoritariamente inofensivo")
default:
    print("No es un lugar seguro para los humanos")
}
// Prints "Mayoritariamente inofensivo"`}
</CodeSnippet>

## Iterando sobre los casos de una Enumeración

Para algunas enumeraciones, es útil tener una colección de todos los casos de esa enumeración. Para agregar esta funcionalidada se agrega `: CaseIterable` después del nombre de la enumeración. Swift expone una colección de todos los casos de la enumeración en la propiedad `allCases`. Aquí hay un ejemplo:

<CodeSnippet>
  {`enum Bebida: CaseIterable {
    case cafe, te, jugo
}\n
let numeroDeOpciones = Bebida.allCases.count
print("\\(numeroDeOpciones) bebidas disponibles")
// Prints "3 bebidas disponibles"`}
</CodeSnippet>

En el ejemplo anterior, se utiliza `Bebida.allCases` para acceder a una colección que contiene todos los casos de la enumeración `Bebida`. Se puede usar `allCases` como cualquier otra colección: los elementos de la colección son instancias del tipo de enumeración, por lo que en este caso son valores de `Bebida`. El ejemplo anterior cuenta cuántos casos hay, y el siguiente ejemplo usa un ciclo `for-in` para iterar sobre todos los casos.


<CodeSnippet>
  {`for bebida in Bebida.allCases {
    print(bebida)
}
// cafe
// te
// jugo`}
</CodeSnippet>

La sintaxis utilizada en los ejemplos anteriores define la enumeración conforme al protocolo [CaseIterable](https://developer.apple.com/documentation/swift/caseiterable). Para obtener información sobre los protocolos, consulte [Protocolos](./protocolos).

## Valores Asociados

Los ejemplos de la sección anterior muestran cómo los casos de una enumeración son un valor definido (y tipado) por sí mismo. Puede establecer una constante o variable en `Planeta.tierra` y verificar este valor más adelante. Sin embargo, a veces es útil poder almacenar valores de otros tipos junto con estos valores de casos. Esta información adicional se denomina _valor asociado_ y varía cada vez que usa ese caso como un valor en su código.

Se pueden definir enumeraciones de Swift para almacenar valores asociados de cualquier tipo dado, y los tipos de valor pueden ser diferentes para cada caso de la enumeración si es necesario. Las enumeraciones similares a estas se conocen como _uniones discriminadas_, _uniones etiquetadas_ o _variantes_ en otros lenguajes de programación.

Por ejemplo, suponga que un sistema de seguimiento de inventario necesita realizar un seguimiento de los productos mediante dos tipos diferentes de código de barras. Algunos productos están etiquetados con códigos de barras 1D en formato UPC, que utiliza los números del `0` to `9`. Cada código de barras tiene un dígito del sistema numérico, seguido de cinco dígitos del código del fabricante y cinco dígitos del código del producto. Estos van seguidos de un dígito de control para verificar que el código se ha escaneado correctamente:

<img
  src="/assets/images/barcode_UPC_2x.png"
  alt="Código de Barras UPC"
  width={252}
  height={120}
  className="figure-small"
/>

Otros productos son etiquetados con códigos de barras 2D en formato QR, el cual puede utilizar cualquiera de los caracteres definidos por ISO 8859-1 y los puede codificar en una cadena de 2,953 caracteres de longitud:

<img
  src="/assets/images/barcode_QR_2x.png"
  alt="Código de Barras QR"
  width={169}
  height={169}
  className="figure-small"
/>

Es conveniente que un sistema de seguimiento de inventario almacene códigos de barras UPC como una tupla de cuatro enteros y códigos de barras de códigos QR como una cadena de cualquier longitud.

En Swift, una enumeración para definir códigos de barras de productos de cualquier tipo podría verse así:

<CodeSnippet>
  {`enum CodigoDeBarras {
    case upc(Int, Int, Int, Int)
    case codigoQR(String)
}`}
</CodeSnippet>

Esto puede leerse como:

“Definir un tipo de enumeración llamada `CodigoDeBarras`, la cual puede tomar un valor `upc` con un tipo de valor asociado `(Int, Int, Int, Int)`, o un valor de  `codigoQR` con un valor asociado de tipo `String`.”

Esta definición no proporciona ningún valor `Int`o `String` real, solo define el tipo de valores asociados que las constantes y variables de `CodigoDeBarras` pueden almacenar cuando son iguales a `CodigoDeBarras.upc` o `CodigoDeBarras.codigoQR`. 

Se pueden entonces crear nuevos tipos de código de barras definiéndolo así:

<CodeSnippet>{`var productoCodigoDeBarras = CodigoDeBarras.upc(8, 85909, 51226, 3)`}</CodeSnippet>

Este ejemplo crea una variable llamada `productoCodigoDeBarras` y le asigna el valor `CodigoDeBarras.upc` con una tupla asociada con valores de (8, 85909, 51226, 3)`.

Se puede asignar al mismo producto un diferente tipo de código de barras:

 <CodeSnippet>{`productoCodigoDeBarras = .codigoQR("ABCDEFGHIJKLMNOP")`}</CodeSnippet>

Hasta ahora, el `CodigoDeBarras.upc` original y sus valores enteros se reemplazan por el nuevo `CodigoDeBarras.codigoQR` y su valor de cadena. Las constantes y variables de tipo `CodigoDeBarras` pueden almacenar un `.upc` o un `.codigoQR` (junto con sus valores asociados), pero solo pueden almacenar uno de ellos en un momento dado.

Se pueden verificar los diferentes tipos de códigos de barras utilizando una sentencia _switch_, similar al ejemplo en [Utilización de los valores de una Enumeración en una sentencia switch](#utilización-de-los-valores-de-una-enumeración-en-una-sentencia-switch). Esta vez, sin embargo, los valores asociados se extraen como parte de la declaración de cambio. Extrae cada valor asociado como una constante (con el prefijo `let`) o una variable (con el prefijo `var`) para usar dentro del cuerpo del caso de la sentencia `switch`: 

<CodeSnippet>
  {`switch productoCodigoDeBarras {
case .upc(let numeroSistema, let fabricante, let producto, let verificacion):
    print("UPC: \\(numeroSistema), \\(fabricante), \\(producto), \\(verificacion).")
case .qrCode(let codigoProducto):
    print("Código QR: \\(codigoProducto).")
}
// Imprime "Código QR: ABCDEFGHIJKLMNOP."`}
</CodeSnippet>

Si todos los valores asociados para un caso de enumeración se extraen como constantes, o si todos se extraen como variables, puede colocar una sola anotación `var` o `let` antes del nombre del caso, por razones de brevedad:

<CodeSnippet>
  {`switch productoCodigoDeBarras {
case let .upc(numeroSistema, fabricante, producto, verificacion):
    print("UPC : \\(numeroSistema), \\(fabricante), \\(producto), \\(verificacion).")
case let .qrCode(productCode):
    print("Código QR: \\(productoCodigoDeBarras).")
}
// Imprime "Código QR: ABCDEFGHIJKLMNOP."`}
</CodeSnippet>

## Valores predefinidos (_raw_)

El ejemplo de código de barras en [Valores Asociados](#valores-asociados) muestra cómo los casos de una enumeración pueden declarar que almacenan valores asociados de diferentes tipos. Como alternativa a los valores asociados, los casos de enumeración pueden incluir valores predeterminados (llamados valores _raw_), que son todos del mismo tipo.

Aquí hay un ejemplo que almacena valores ASCII sin procesar junto con casos de enumeración con nombre:

<CodeSnippet>
  {`enum CaracteresDeControlASCII: Character {
    case tabulador = "\\t"
    case avanceDeLinea = "\\n"
    case retornoDeCarro = "\\r"
}`}
</CodeSnippet>

Aquí, los valores predefinidos (_raw_) para la enumeración `CaracteresDeControlASCII` están definidos para ser de tipo `Character`, y son un conjunto de los caracteres de control ASCII más comunes. Los valores de tipo caracter `Character` están descritos en [Cadenas y caracteres](./cadenas-y-caracteres).

Los valores predefinidos pueden ser cadenas, caracteres, o cualquier tipo de dato numérico entero o flotante. Cada valor predeterminado debe ser único dentro de la declaración de la enumeración.

<Callout>
  Los valores predefinidos _no son_ lo mismo que _valores asociados_. Los valores predefinidos son un conjunto
  de valores prellenados cuando se define la enumeración en el codigo, como
  los tres caracteres ASCII del ejemplo anterior. El valor predefinido para un caso de  enumeración en particular
  es siempre el mismo. Los valores asociados se establecen cuando se crea una nueva constante
  o variable basada en los caso de la enumeración, y puede ser diferente
  cada vez que se hace.
</Callout>

## Valores Asociados de Forma Implícita

Cuando se trabaja con enumeraciones que almacenan valores sin formato de cadena o enteros, no tiene que asignarse explícitamente un valor sin formato para cada caso. Cuando no lo hace, Swift asigna automáticamente los valores por usted.

Por ejemplo, cuando se utilizan números enteros para valores brutos, el valor implícito para cada caso es uno más que el caso anterior. Si el primer caso no tiene un valor establecido, su valor es `0`.

La siguiente enumeración es un refinamiento de la enumeración anterior `Planeta`, con valores enteros sin procesar para representar el orden de cada planeta desde el sol:

<CodeSnippet>
  {`enum Planeta: Int {
    case mercurio = 1, venus, tierra, marte, jupiter, saturno, urano, neptuno
}`}
</CodeSnippet>

En el ejemplo anterior, `Planeta.mercurio` tiene un valor definido explicitamente de `1`, `Planeta.venus` tiene un valor predefinido explictamentehas de `2`, y así sucesivamente.

Cuando se utilizan cadenas para valores predefinidos, el valor implícito predeterminado para cada caso es el texto del nombre de ese caso.

La siguiente enumeración es una mejora de la enumeración anterior `PuntoCardinal`, con valores de cadena que representan el nombre de cada dirección:

<CodeSnippet>
  {`enum PuntoCardinal: String {
    case norte, sur, este, oeste
}`}
</CodeSnippet>

En el ejemplo anterior, `PuntoCardinal.sur` tiene un valor predefinido implicitamente de `"sur"`, y así sucesivamente.

Se puede acceder a los valores predefinidos de forma implícita de cada caso mediante la propieadad `rawValue`:

<CodeSnippet>
  {`let ordenTierra = Planeta.tierra.rawValue
// ordenTierra es 3\n
let  direccionAtardecer = PuntoCardinal.oeste.rawValue
// direccionAtardecer es "oeste"`}
</CodeSnippet>

### Inicializando de un valor predefinido

Si se define una enumeración con un tipo de predefinido (_raw_), la enumeración recibe automáticamente un inicializador que toma un valor del tipo del valor predefinido (como un parámetro denominado `rawValue`) y devuelve un caso de enumeración o un valor `nil`. Se puede usar este inicializador para intentar crear una nueva instancia de la enumeración.

Este ejemplo identifica a Urano a partir de su valor predeterminado de 7:

<CodeSnippet>
  {`let planetaPosible = Planeta(rawValue: 7)
  // planetaPosible es del tipo Planeta? 
  // y es igual al planeta Planet.urano`}
</CodeSnippet>

No todos los valores posibles `Int` encontraan un planeta que coresponda, sin embargo. Debido a esto, las capas de valores predeterminados regresan un caso de enumeración _optional_ . En el ejemplo anterior, `planetaPosible` es del tipo `Planeta?`, o “optional `Planeta`.”

<Callout>
  El valor inicial de un tipo predefinido es un inicalizador falible, porque no cada valor predefinido
  regresará un caso de enumeración. Para mayor información, vea [Declaraciones Inicializadores Falibles](../referencia-del-lenguaje/declaraciones#inicializadores-falibles).
</Callout>

Si se intenta buscar un planeta en la posición `11`, el valor opcional de `Planeta` regresado por el valor predefinido será `nil`:

<CodeSnippet>
  {`let posicionBuscada = 11\n
if let algunPlaneta = Planeta(rawValue: posicionBuscada) {
    switch algunPlaneta {
    case .tierra:
        print("Mayoritariamente inofensivo")
    default:
        print("No es un lugar seguro para humanos")
    }
} else {
    print("No hay un planeta en la posición \\(posicionBuscada)")
}
// Imprime "o hay un planeta en la posición 11"`}
</CodeSnippet>

Este ejuemplo usa el vínculo opcional para intentar acceder al Planeta con un valor predefinido de `11`. La sentencia `if let algunPlaneta = Planeta(rawValue: 11)` crea un planeta opcional `Planeta`, y le asigna a  `algunPlaneta` al valor de ese planeta `Planet` opcional si puede ser recuperado. En este caso, no es posible recuperar un planeta que se encuentre en la posición `11`, y por lo tante la sentencia `else` es ejecutada en su lugar.

## Enumeraciones recursivas

Una _enumeración recursiva_ es una enumeración que tiene otra instancia de la enumeración como valor asociado para uno o más de los casos de enumeración. Se indica que un caso de enumeración es recursivo al escribir `indirect` antes _enum_, lo que le dice al compilador que inserte la capa necesaria de direccionamiento indirecto.

Por ejemplo, aquí hay una enumeración que almacena expresiones aritméticas simples:

<CodeSnippet>
  {`enum ExpresionAritmetica {
    case numero(Int)
    indirect case adicion(ExpresionAritmetica, ExpresionAritmetica)
    indirect case multiplicacion(ExpresionAritmetica, ExpresionAritmetica)
}`}
</CodeSnippet>

También se puede escribir la palabra reservada `indirect` ante del inicio de la enumeración para permitir la indirección de todos los casos de la enumeración que tienen un valor asociado:

<CodeSnippet>
  {`indirect enum ExpresionAritmetica {
    case numero(Int)
    case adicion(ExpresionAritmetica, ExpresionAritmetica)
    case multiplicacion(ExpresionAritmetica, ExpresionAritmetica)
}`}
</CodeSnippet>

Esta enumeración puede almacenar tres tipos de expresiones aritméticas: un número simple, la suma de dos expresiones y la multiplicación de dos expresiones. Los casos de `suma` y `multiplicacion` tienen valores asociados que también son expresiones aritméticas; estos valores asociados hacen posible anidar expresiones. Por ejemplo, la expresión `(5 + 4) * 2` tiene un número en el lado derecho de la multiplicación y otra expresión en el lado izquierdo de la multiplicación. Debido a que los datos están anidados, la enumeración utilizada para almacenar los datos también debe admitir el anidamiento; esto significa que la enumeración debe ser recursiva. El siguiente código muestra la enumeración recursiva `ExpresionAritmetica` que se crea para `(5 + 4) * 2`:

<CodeSnippet>
  {`let cinco = ExpresionAritmetica.numero(5)
let cuatro = ExpresionAritmetica.numero(4)
let suma = ExpresionAritmetica.adicion(cinco, cuatro)
let producto = ExpresionAritmetica.multiplicacion(suma, ExpresionAritmetica.numbero(2))`}
</CodeSnippet>

Una función recursiva es una forma sencilla de trabajar con datos que tienen una estructura recursiva. Por ejemplo, aquí hay una función que evalúa una expresión aritmética:

<CodeSnippet>
  {`func evaluar(_ expresion: ExpresionAritmetica) -> Int {
    switch expresion {
    case let .numero(valor):
        return valor
    case let .adicion(izquierda, derecha):
        return evaluar(izquierda) + evaluar(derecha)
    case let .multiplicacion(izquierda, derecha):
        return evaluar(izquierda) * evaluate(derecha)
    }
}\n
print(evaluar(producto))
// Imprime "18"`}
</CodeSnippet>

Esta función evalúa un número simple simplemente devolviendo el valor asociado. Evalúa una adición o multiplicación evaluando la expresión del lado izquierdo, evaluando la expresión del lado derecho y luego sumándolas o multiplicándolas.
